## 1.两阶段锁的概念是什么? 对事务使用有什么帮助?
    两阶段锁协议
        在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，
        而是要等到事务结束时才释放。这个就是两阶段锁协议。
        假设某事务在执行的过程中，会依次更新数据库中的行  A  B  C   会依次的去获取 A  B  C 的行锁，
        但是只有等到事务提交的时候，才会释放着三个行的行锁
    使用提醒/or帮助
    在不影响业务执行流程的情况下  先去更新影响面较小的行（避免占用行锁时间过长影响其他事务处理） 把影响面较大的行（会有较多不同事务更新的行）最后再更新

## 2.死锁的概念是什么? 举例说明出现死锁的情况.
    死锁概念：
        当并发系统中不同的线程出现循环资源依赖，涉及的线程都在等到别的线程释放资源时
        就会导致这几个线程都进入无线等待状态，称为死锁
    死锁例子
        以数据库中的操作为例
        AB同时开启事务后，A先更新 第i行，然后B更新第j行
        之后如果A想要更新第j行，此时第j行的行锁已经被事务B获取到了，A只能等
        可是B想要更新第i行，第i行的行锁已经被A获取到了，B取不到，也只能等
        AB两个事务之间形成了循环依赖，且如果没有外部的干涉条件，循环依赖等待并不会被破坏，就一直死锁下去了
        demo的例子图片存放在了同等文件夹下的图片中

## 3.死锁的处理策略有哪两种?
    1 等待超时，以mysql中的Innodb引擎为例，默认超时时间为50s，
      当线程等待超过50s还没有等待到所需要的，就会超时退出
    2 死锁检测，主动发起死锁检测，一旦判断事务之间形成了死锁，主动回滚形成死锁链条只能够的某一个事务
      以便于其他事务继续执行

## 4.等待超时处理死锁的机制什么?有什么局限?
    在 InnoDB 中，innodb_lock_wait_timeout 的默认值是 50s，
    意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，
    然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。

## 5.死锁检测处理死锁的机制是什么? 有什么局限?
    机制：
        每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，
        如此循环，最后判断是否出现了循环等待，也就是死锁。
    局限：
        在大量并发的情况下，会造成CPU资源浪费
        每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，
        这是一个时间复杂度是 O(n) 的操作。
        假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的。
        虽然最终检测的结果是没有死锁，但是这期间要消耗大量的 CPU 资源。
        因此，你就会看到 CPU 利用率很高，但是每秒却执行不了几个事务。


##  6. 有哪些思路可以解决热点更新导致的并发问题?
    方法一
        头痛医头
            就是如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。
            会存在风险，如果关闭了死锁检测之后又产生了死锁，会造成大量的业务处理超时（事务等待超时到了限定值后退出了）
        控制并发度
            如果有千级别并发，死锁检测量级是百万级
            如果控制在了10级别并发，死锁检测级别也就在100量级
            会有一定限制，并发量并不是说控制就可以控制了的，如果客户端过多并发量控制不住
        对于修改相同行的操作，在进入引擎之前排队
            通过中间件or修改mysql源码实现
            弊端，技术上实现可能较为复杂
        逻辑上单行修改变成多行统计，更新时只要获取到了一行的行锁就可以
            弊端：业务逻辑上会变复杂


![image](死锁-死锁检测.png)